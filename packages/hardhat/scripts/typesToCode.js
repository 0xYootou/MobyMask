const types = require('./types');
const fs = require('fs');
const path = require('path');
const {
  signTypedData,
  TypedDataUtils,
  typedSignatureHash,
  SignTypedDataVersion,
  encodeData,
  encodeType,
} = require('signtypeddata-v5').TypedDataUtils;

function generateTypeStringFrom (types) {
  return Object.keys(types.types).map((typeName) => {
    const fields = types.types[typeName];
    const typeHash = `bytes32 constant ${typeName.toUpperCase()}_TYPEHASH = keccak256("${encodeType(typeName, types.types)}");\n`;
    const struct = `struct ${typeName} {\n${fields.map((field) => { return `  ${field.type} ${field.name};\n`}).join('')}}\n`
    return `${struct}\n${typeHash}`;
  })
}

function updateSolidity () {
  const typeHashes = generateTypeStringFrom(types);
  console.log(typeHashes.join('\n'))
  const filePath = path.join(__dirname, '../contracts/Delegatable.sol');
  const file = fs.readFileSync(filePath, 'utf8').toString();
  const oldFile = file.split('\n');
  const newFile = [];

  let autoGenRange = false;
  oldFile.forEach((line) => {
    if (line.includes('// BEGIN EIP712 AUTOGENERATED CODE')) {
      autoGenRange = true;
      newFile.push(line);
      newFile.push(...typeHashes)
      return true;
    }

    if (line.includes('// END EIP712 AUTOGENERATED CODE')) {
      autoGenRange = false;
      newFile.push(line);
      return true;
    }

    // Return any line not in the autoGenRange
    if (!autoGenRange) {
      newFile.push(line);
    }
  })

  const newFileString = newFile.join('\n');
  // console.log(newFileString)
  fs.writeFileSync(filePath, newFileString);
}

module.exports = {
  generateTypeStringFrom,
  updateSolidity,
}